---
layout: default
title: メモ - ぺんぎんノート
---
<style>
b {
  color:salmon;
}
</style>
<p>何か書きたくなったらここに書きます。</p>
<hr>
<p>
  $f(x)$から$f(x+1)$と$f(2x)$を求めることができれば、$f(x)$は$O(\log x)$で求まる<br>
  乗算は、指数に注目すると加算になる。加算では行列累乗が使える<br>
  <code>int dx = (i - 2) % 2, dy = (i - 1) % 2;</code><br>
  実装の重い問題では、<code>map&lt;int, map&lt;char, vector&lt;string&gt;&gt;&gt;</code>などを使うことがある。<b>逃げないこと</b><br>
  頂点の次数を数える方法で楽なのは、辺の入力時についでに数えるという方法<br>
  重みのないグラフに重みを持たせることで解ける問題がある<br>
  「木があって、辺が交わらないように円周上に頂点を配置する方法は何通りあるか」は木DP<br>
  <b>メモに残せない系問題が多い（Adhocな思考が要求される）</b><br>
  条件を満たさない状況をひとつずつ丁寧に排除していく系の問題がある。苦手な人が多い印象<br>
  $a+b=a \otimes b$を満たす$(a, b)$はビットに注目<br>
  <hr>
  グリッド上で4方向に累積和。2方向よりもシンプルになることがある<br>
  指数のmodは底のmod-1で取る<br>
  <b>添字が難しい二分探索の問題をバグ無しで解く方法はまだ確立できていない</b><br>
  $S$と$T$の両方向からダイクストラをすれば、最短経路が求まる<br>
  ダイクストラに数行コードを足すだけで、最短経路は何通りあるかが求まる<br>
  「周期性のある数列の$N$番目までを足した合計」などを求めるときは数学を使う<br>
  こういった問題は$300$点問題でよく出る印象。$500$点以上では部分部分で使われる。慣れること<br>
  優先度付きキューとdequeの存在を忘れないこと<br>
  配列の要素を削除して左詰めする操作を、シフト量をBITに保存することで$O(\log N)$で実現<br>
  <b>フローは今のところ使わない</b><br>
  <hr>
  通常の<code>for</code>文を、「<code>[0, 1)</code>〜<code>[N-1, N)</code>の範囲を見る」と考える<br>
  座標をベクタ配列に追加してソートすれば、それだけで座標圧縮したことになる<br>
  dp配列を作るときは、とりあえず必要そうな状態を全部突っ込む。あとで減らす<br>
  公差$d$の等差数列は、要素を$d$で割ることで公差$1$の等差数列になる<br>
  <b>期待値を求めるときに、dpを使わずにただ定義通りに実装すればいいことがある</b><br>
  数学の命題を使うと考察が捗ることがある。逆に使わないと、複雑で訳がわからなくなる<br>
  行列の単位元を作りたいけど、RustでもHaskellでもうまい方法が見つからない<br>
  しゃくとり法は、<code>for</code>文のブロック内のある範囲を「必ず条件を満たす範囲」にするとバグりにくい<br>
  しゃくとり法の最後の一行は<code>if (l >= r) r = l, acc = e;</code>とする<br>
  <b>グラフ関連の証明を勉強して、グラフに対する感覚を養っていきたい</b><br>
  <hr>
  行列のランクをまだ勉強していない（理解はしているけど、使い所がわからない）<br>
  01BFSのときに使うdequeには、高々2つの距離しか保存されない<br>
  <b>まだ、遅延セグ木をバグなしで使える気がしない。</b>おそらくまだ何か勘違いしている<br>
  累積和の代わりにセグ木を使うのもいいかもしれない<br>
  セグ木上の要素の削除を、単位元による更新で行っているのが面白かった<br>
  順序を無視できるものについて、ある順序に並び替えることで解ける問題になることがある<br>
  ↑この解法かなり好き<br>
  <b>考察は再帰のようなもの</b><br>
  累積和は方向に気をつけないといけないけど、セグ木だとその必要がなくなる<br>
  Trie木の型は<code>vector&lt;map&lt;char, int&gt;&gt;</code><br>
  <hr>
  「個数」という扱いにくいものを、「最大値」という扱いやすいものにする<br>
  貰うDPは式で表しやすく、配るDPは式で表しにくい。<b>どちらを使うかが自分の中でまだ決まっていない</b><br>
  <b>グラフに関するアルゴリズムの計算量を明確にしておきたい</b><br>
  <ul style="margin:0;">
    <li>DFSは$O(E)$、BFSも$O(E)$</li>
    <li>ダイクストラは$O(E + V \log V)$</li>
    <li>ベルマンフォードは$O(EV)$</li>
    <li>各頂点の次数は$O(E)$（辺の入力時についでに数える）</li>
    <li>最短経路の個数は、ダイクストラを少し修正すれば求まるので$O(E + V \log V)$</li>
    <li>重みなし無向グラフの直径は、DFSを2回行えば求まるので$O(E)$</li>
    <li>重みなし無向グラフの中心は、DFSを3回行えば求まるので$O(E)$</li>
  </ul>
  <b>数え上げ問題がまだ苦手</b><br>
  <b>高難易度の問題を安定して自力で解けるようになることを目標とする。早解きを目標としないこと</b><br>
  modを取ってdpの状態数を減らす<br>
  必要なのが前の状態だけのときは、dp配列のサイズを大幅に減らせる<br>
  3つのポインタ。真ん中のポインタを固定して、左右のポインタはしゃくとり法 ← 実装難易度高め<br>
  二乗の木DP。葉の状態はすぐに定義できるけど、親がどうマージしていくかについて考えるのが難しい<br>
  <b>実装に困ったら他の人のコードを参考にする。写経すれば自然と理解できるので手を動かすこと</b><br>
  <hr>
  全方位木DPが理解できた。最初は普通の木DPで子→親の方向に更新、次は親→子の方向に更新<br>
  <a target="_blank" href="https://www.learning-algorithms.com/entry/2018/04/02/013823">こちら</a>の実装が理解しやすかった<br>
  mapに順序付けしたいときは<code>map&lt;char, int, greater&lt;char&gt;&gt;</code>という風にする<br>
  <b>考察と実装の間に乖離があることを理解する。</b>たとえば、ぷよぷよでぷよが消える条件は「4つ以上繋がっているとき」と一言で言い表せるけど、実装するとなると、再帰や配列外参照について考慮しなければならない。その事実から目を背けないこと<br>
  Codeforcesでは、実装が重いだけの問題に対して批判的なコメントをすると、沢山の高評価を貰える傾向にある。Twitterでも、こういう問題に対して批判する人をたまに見る。だからといってそれが、問題を解かない理由になるわけではない。ついこういう問題からは逃げたくなるけど、<b>逃げないこと！！</b>（再三自分に言い聞かせる）<br>
</p>
