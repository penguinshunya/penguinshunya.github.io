---
layout: default
title: RustでWebアプリ開発日記
---
2020/08/12

エラー処理の項を読み終えた。  
`Result`を使うか`panic!`を使うかの判断基準が明確に定められていて面白かった。  
あと、データの正当性チェックを外部に追い出すために`enum`と`impl`を使うというのはなるほどと思った。


2020/08/11

[Rustのチュートリアル](https://doc.rust-jp.rs/book/second-edition/)を進めている。  
先ほど「8.3. ハッシュマップ」を終えた。そして演習問題を解いた。  
解くことはできたけど、もっと簡潔な方法が存在する気がする。  

知らないプログラミング言語を使うといつもこの感覚を味わう。  
C++を学びたての頃も、文字列の各文字にアクセスする方法が添え字アクセス以外にも存在し、そちらのほうが良いと思っていた。  
しかし実際は、確かに文字列をイテレータのように扱う方法は存在するが、それよりも添え字アクセスのほうが自然であり高速である。  

このように、最初に学んだ方法が悪い方法ではないこともある。  
特に今回はRustの公式のチュートリアルを進めているので、学ぶ方法が悪い方法でないことは確かだ。もっと効率の良い方法は存在するかもしれないが、基礎さえ見についていればおそらくすぐに理解できる。

<hr>

次のような問題を考える。  

文字列を受け取ると、先頭文字を取り除いた新たな文字列を返す関数を作成してください。もし元の文字列が空文字である場合はNoneを返してください。

この問題を次のように実装した。

<script src="https://ideone.com/e.js/j6mxyL" type="text/javascript" ></script>

次のような不安がある。

* `s.chars().enumerate()`という記述が長い。もっといい書き方がありそう
* `ret`という変数を新たに用意する必要はあるか（もっと関数型っぽく書けないか）
* `remove_first`の引数の型は本当に`&str`でいいか
* 戻り値の型は`Option<String>`で最適かどうか

<hr>

面白い文章を見つけた。  
公式の文章に、ある関数の戻り値の型を調べる方法として、APIのドキュメントを確認するほかにもコンパイラに確認することもできると書かれていた。わざとコンパイルエラーを発生させて型を確認するという方法が公式で認められているとは思わなかった。  

Rustのチュートリアルを進めていると、仕組みに感動したり常識が覆されたりする。  

<hr>

`Result<T, E>`と`Option<T>`がたまにごっちゃになる。

<hr>

* `let f = f;`みたいな書き方が許されているのが面白い。他の言語では、このような書き方をすると「既に変数`f`が宣言されています」というエラーが発生する
* `mut`がないベクタ配列は変更不可なのが安心する。JavaScriptでは、`const arr = [];`としても配列に要素を追加できるので安心できない
* パターンマッチが純粋に好き。すべての例外を補足する感覚が堪らない
* マッチガードが少し無理矢理感
* `?`演算子を使うことで冗長なパターンマッチのコードを簡潔にできる
* 公式の文書に「`?`演算子は、`Result`を返す関数でしか使用できない」とあるが、実際には`Option`を返す関数でも使用できる
* `unwrap`や`except`が「エラーの処理方法を決定する前のプロトタイプの段階で便利。プログラムをより良くするときのマーカーの役割も持つ」というように表現されていて面白い。Rustは、いきなり洗練されたコードを書くことを要求しない。その場凌ぎのコードを書くことも許容する。ただ、それはマーカーとしてコード内に残る。やっぱりRust好き