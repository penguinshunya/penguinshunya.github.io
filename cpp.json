{
	"Competitive Programming Template": {
		"prefix": "cpt",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define rep(i, n) for (int i = 0; i < int(n); i++)",
			"#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)",
			"#define reps(i, n) for (int i = 1; i <= int(n); i++)",
			"#define rreps(i, n) for (int i = int(n); i >= 1; i--)",
			"#define repi(i, a, b) for (int i = int(a); i < int(b); i++)",
			"#define each(x, y) for (auto &x : y)",
			"#define all(a) (a).begin(), (a).end()",
			"#define bit(b) (1ll << (b))",
			"#define uniq(v) (v).erase(unique(all(v)), (v).end())",
			"#define rsort(v) sort(all(v)); reverse(all(v))",
			"",
			"using namespace std;",
			"",
			"using i32 = int;",
			"using i64 = long long;",
			"using f80 = long double;",
			"using vi32 = vector<i32>;",
			"using vi64 = vector<i64>;",
			"using vf80 = vector<f80>;",
			"using vstr = vector<string>;",
			"",
			"inline void yes() { cout << \"Yes\" << '\\n'; exit(0); }",
			"inline void no() { cout << \"No\" << '\\n'; exit(0); }",
			"inline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }",
			"inline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }",
			"void solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }",
			"template<typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};",
			"template<typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};",
			"template<typename T> inline void amax(T &x, T y) { if (x >= y) x = y; }",
			"template<typename T> inline void amin(T &x, T y) { if (x <= y) x = y; }",
			"template<typename T> inline T power(T x, i64 n) { T r = 1; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }",
			"template<typename T> istream& operator>>(istream &is, vector<T> &v) { for (auto &x : v) is >> x; return is; }",
			"template<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }",
			"",
			"void solve() {",
			"  $0",
			"}",
		]
	},
	"ModInt": {
		"prefix": "modint",
		"body": [
			"template<int mod>",
			"struct ModInt {",
			"  int x;",
			"  ModInt(): x(0) {}",
			"  ModInt(int a) { x = a % mod; if (x < 0) x += mod; }",
			"  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }",
			"  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }",
			"  ModInt &operator*=(ModInt that) { x = (i64) x * that.x % mod; return *this; }",
			"  ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }",
			"  ModInt operator-() { return ModInt(-this->x); }",
			"  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }",
			"  ModInt inverse() {",
			"    int a = x, b = mod, u = 1, v = 0;",
			"    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }",
			"    return ModInt(u);",
			"  }",
			"  #define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }",
			"    op(+, +=) op(-, -=) op(*, *=) op(/, /=)",
			"  #undef op",
			"  #define op(o) bool operator o(ModInt that) const { return x o that.x; }",
			"    op(==) op(!=) op(<) op(<=) op(>) op(>=)",
			"  #undef op",
			"};",
			"",
			"using mint = ModInt<1000000007>;",
		]
	},
	"ModCalc": {
		"prefix": "modcalc",
		"body": [
			"template<typename T>",
			"struct ModCalc {",
			"  vector<T> fac, finv;",
			"  ModCalc(int max) {",
			"    fac = vector<T>(max + 1);",
			"    finv = vector<T>(max + 1);",
			"    fac[0] = 1;",
			"    reps(i, max) fac[i] = fac[i - 1] * i;",
			"    finv[max] = (T) 1 / fac[max];",
			"    rreps(i, max) finv[i - 1] = finv[i] * i;",
			"  }",
			"  T com(int a, int b) {",
			"    if (a < 0) return 0;",
			"    if (b < 0 || b > a) return 0;",
			"    return fac[a] * finv[a - b] * finv[b];",
			"  }",
			"};",
			"",
			"using mcalc = ModCalc<mint>;"
		]
	},
	"Point": {
		"prefix": "point",
		"body": [
			"struct Point {",
			"  f80 x, y;",
			"  Point() : x(), y() {}",
			"  Point(f80 x, f80 y) : x(x), y(y) {}",
			"  Point operator+(const Point &a) const { return Point(x + a.x, y + a.y); }",
			"  Point operator-(const Point &a) const { return Point(x - a.x, y - a.y); }",
			"  f80 operator%(const Point &a) const { return x * a.x + y * a.y; }",
			"  f80 operator*(const Point &a) const { return x * a.y - y * a.x; }",
			"};",
		]
	},
	"UnionFind": {
		"prefix": "unionfind",
		"body": [
			"struct UnionFind {",
			"  vector<int> par;",
			"  UnionFind(int n) {",
			"    par = vector<int>(n + 1);",
			"    iota(all(par), 0);",
			"  }",
			"  int root(int x) {",
			"    if (par[x] == x) return x;",
			"    return par[x] = root(par[x]);",
			"  }",
			"  void unite(int x, int y) {",
			"    x = root(x);",
			"    y = root(y);",
			"    if (x == y) return;",
			"    par[x] = y;",
			"  }",
			"  bool same(int x, int y) {",
			"    return root(x) == root(y);",
			"  }",
			"};",
		]
	},
	"Comparable Struct": {
		"prefix": "comparable",
		"body": [
			"struct $1 {",
			"  $2",
			"  bool operator<(const $1 &that) const {",
			"    $0",
			"    return false;",
			"  }",
			"};",
		]
	},
	"Fenwick Tree": {
		"prefix": "fenwicktree",
		"body": [
			"struct FenwickTree {",
			"  vi64 v;",
			"  FenwickTree(i32 n) {",
			"    v = vi64(n);",
			"  }",
			"  void add(i32 i, i64 x) {",
			"    for (i++; i <= v.size(); i += i & -i) {",
			"      v[i - 1] += x;",
			"    }",
			"  }",
			"  i64 sum(i32 i) {",
			"    i64 r = 0;",
			"    for (; i >= 1; i -= i & -i) {",
			"      r += v[i - 1];",
			"    }",
			"    return r;",
			"  }",
			"};",
		]
	},
	"Crossing": {
		"prefix": "crossing",
		"body": [
			"template<typename Ord> i64 crossing(vector<Ord> v) {",
			"  auto copy = v;",
			"  sort(all(copy));",
			"  uniq(v);",
			"  map<Ord, i32> mp;",
			"  rep(i, copy.size()) mp[copy[i]] = i;",
			"  rep(i, v.size()) v[i] = mp[v[i]];",
			"  FenwickTree ft(v.size());",
			"  i64 ret = 0;",
			"  rep(i, v.size()) {",
			"    ret += i - ft.sum(v[i] + 1);",
			"    ft.add(v[i], 1);",
			"  }",
			"  return ret;",
			"}",
		]
	},
	"Segment Tree": {
		"prefix": "segmenttree",
		"body": [
			"template<typename Monoid>",
			"struct SegmentTree {",
			"  using F = function<Monoid(Monoid, Monoid)>;",
			"  ",
			"  int sz;",
			"  vector<Monoid> seg;",
			"  ",
			"  const F f;",
			"  const Monoid M1;",
			"  ",
			"  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {",
			"    sz = 1;",
			"    while (sz < n) sz <<= 1;",
			"    seg.assign(2 * sz, M1);",
			"  }",
			"",
			"  void set(int k, const Monoid &x) {",
			"    seg[k + sz + 1] = x;",
			"  }",
			"",
			"  void build() {",
			"    for (int k = sz - 1; k > 0; k--) {",
			"      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
			"    }",
			"  }",
			"",
			"  void update(int k, const Monoid &x) {",
			"    k += sz + 1;",
			"    seg[k] = x;",
			"    while (k >>= 1) {",
			"      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);",
			"    }",
			"  }",
			"",
			"  Monoid query(int a, int b) {",
			"    Monoid L = M1, R = M1;",
			"    for (a += sz + 1, b += sz + 1; a < b; a >>= 1, b >>= 1) {",
			"      if (a & 1) L = f(L, seg[a++]);",
			"      if (b & 1) R = f(seg[--b], R);",
			"    }",
			"    return f(L, R);",
			"  }",
			"",
			"  Monoid operator[](const int &k) const {",
			"    return seg[k + sz + 1];",
			"  }",
			"};",
		]
	},
	"Flow": {
		"prefix": "flow",
		"body": [
			"template<class T>",
			"struct Flow {",
			"  struct Edge {",
			"    int to;",
			"    T cap;",
			"    int rev;",
			"  };",
			"",
			"  int n, s, t;",
			"  vector<vector<Edge>> g;",
			"  vector<bool> used;",
			"",
			"  Flow(int n, int s, int t) : n(n), s(s), t(t) {",
			"    g = vector<vector<Edge>>(n);",
			"  }",
			"",
			"  void add(int from, int to, T cap) {",
			"    g[from].push_back({ to, cap, (int) g[to].size() });",
			"    g[to].push_back({ from, 0, (int) g[from].size() - 1 });",
			"  }",
			"",
			"  T dfs(int v, T f) {",
			"    if (v == t) {",
			"      return f;",
			"    }",
			"    used[v] = true;",
			"    for (auto &e : g[v]) {",
			"      if (used[e.to] || e.cap <= 0) {",
			"        continue;",
			"      }",
			"      T d = dfs(e.to, min(f, e.cap));",
			"      if (d > 0) {",
			"        e.cap -= d;",
			"        g[e.to][e.rev].cap += d;",
			"        return d;",
			"      }",
			"    }",
			"    return 0;",
			"  }",
			"",
			"  T max_flow() {",
			"    T sum = 0;",
			"    while (true) {",
			"      used = vector<bool>(n);",
			"      T f = dfs(s, numeric_limits<T>::max());",
			"      if (f == 0) {",
			"        break;",
			"      }",
			"      sum += f;",
			"    }",
			"    return sum;",
			"  }",
			"};",
		]
	},
	"Prime": {
		"prefix": "prime",
		"body": [
			"inline bool is_prime(i32 n) {",
			"  if (n < 2) {",
			"    return 0;",
			"  }",
			"  for (i32 i = 2; i * i <= n; i++) {",
			"    if (n % i == 0) {",
			"      return false;",
			"    }",
			"  }",
			"  return true;",
			"}",
			"",
			"vi32 prime_list(i32 n) {",
			"  vi32 primes;",
			"  vector<bool> f(n, true);",
			"  f[0] = f[1] = false;",
			"  repi(i, 2, n) {",
			"    if (!f[i]) continue;",
			"    primes.push_back(i);",
			"    for (int j = i * 2; j < n; j += i) {",
			"      f[j] = false;",
			"    }",
			"  }",
			"  return primes;",
			"}",
		]
	}
}
